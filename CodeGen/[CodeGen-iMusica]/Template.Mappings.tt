<#@ template debug="true" hostSpecific="true" #>
<#@ property name="NameSpace" type="System.String" processor="PropertyProcessor" #>
<#@ property name="MyMetaDomainConverterWrapper" type="Oragon.CodeGen.MetaData.MyMetaDomainConverterWrapper, Oragon.CodeGen.MetaData.Domain" processor="PropertyProcessor" #>
<#@ output extension=".cs" #>
<#@ Assembly Name="System.Core.dll" #>
<#@ Assembly Name="System.Xml.dll" #>
<#@ Assembly Name="System.Xml.Linq.dll" #>
<#@ Assembly Name="System.Windows.Forms.dll" #>
<#@ Assembly Name="Oragon.CodeGen.MetaData.DataBase.dll" #>
<#@ Assembly Name="Oragon.CodeGen.MetaData.Domain.dll" #>
<#@ Assembly Name="MyGenUtility.dll" #>
<#@ import namespace="System" #><#@ import namespace="System.IO" #><#@ import namespace="System.Diagnostics" #><#@ import namespace="System.Linq" #><#@ import namespace="System.Xml.Linq" #><#@ import namespace="System.Collections" #><#@ import namespace="System.Collections.Generic" #><#@ import namespace="Oragon.CodeGen.MetaData.Domain" #><#@ import namespace="Oragon.CodeGen.MetaData.Domain" #><#@ import namespace="Oragon.CodeGen.MetaData.DataBase" #><#@ import namespace="MyGeneration" #> 
<#
	DomainModel domain = MyMetaDomainConverterWrapper.GetModel();
	string dbPrefix = string.Empty;
	string dbSufix = string.Empty;
	if(domain.Entities.First().Table is Oragon.CodeGen.MetaData.DataBase.MySql.MySqlTable)
	{
		dbPrefix = "`";
		dbSufix = "`";
	}
	if(domain.Entities.First().Table is Oragon.CodeGen.MetaData.DataBase.Sql.SqlTable)
	{
		dbPrefix = "[";
		dbSufix = "]";
	}
	//System.Diagnostics.Debugger.Launch();
#>
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Runtime.Serialization;
using System.Text;
using System.Xml.Serialization;
using <#=NameSpace#>.Entity;
using FluentNHibernate.Mapping;

namespace <#=NameSpace#>.Mapping
{
<#	foreach (Oragon.CodeGen.MetaData.Domain.Entity currentEntity in domain.Entities)
	{
		List<Oragon.CodeGen.MetaData.Domain.Property> propertiesToMap = new List<Oragon.CodeGen.MetaData.Domain.Property>(currentEntity.Properties);

#>
	
	public partial class <#= currentEntity.Name #>Mapper : ClassMap<<#=NameSpace#>.Entity.<#= currentEntity.Name #>>
	{

		partial void CompleteMappings();

		public <#= currentEntity.Name #>Mapper()
		{
			Table("<#= dbPrefix + currentEntity.Table.Name + dbSufix#>");
			OptimisticLock.None();
			DynamicUpdate();
<#			List<IColumn> pkColumns = currentEntity.Table.PrimaryKeys.ToList();
			if (pkColumns.Count == 0)
#>			############################################################################################
			ERRO TABELA SEM PK
			############################################################################################
<# 			else if (pkColumns.Count == 1)
			{
				IColumn uniquePkColumn = pkColumns[0];
				bool isReferenceFk = uniquePkColumn.ForeignKeys.Where(it => it.ForeignColumns.Contains(uniquePkColumn)).Any();
				if(uniquePkColumn.IsInForeignKey && isReferenceFk)
				{
					
#>
	--> <-- --> <-- --> <-- --> <-- --> <-- --> <-- --> <-- --> <-- --> <-- --> <-- --> <-- --> <-- --> <-- --> <-- --> <-- 
	Não suportado. A PK única composta pela coluna <#= uniquePkColumn.Name #> é uma referência a outra entidade.
	--> <-- --> <-- --> <-- --> <-- --> <-- --> <-- --> <-- --> <-- --> <-- --> <-- --> <-- --> <-- --> <-- --> <-- --> <-- 
<#							
				}
				else
				{
					Oragon.CodeGen.MetaData.Domain.Property pkProperty = GetPropertyByColumn(propertiesToMap, uniquePkColumn, true);
					if(pkProperty is Oragon.CodeGen.MetaData.Domain.ValueTypeProperty)
					{
						Oragon.CodeGen.MetaData.Domain.ValueTypeProperty pkValueTypeProperty = (Oragon.CodeGen.MetaData.Domain.ValueTypeProperty)pkProperty;
						string generated = (pkValueTypeProperty.Column.IsAutoKey ? ".GeneratedBy.Identity()" : ".GeneratedBy.Assigned()");
#>
			Id(it => it.<#= pkProperty.Name #>, "<#= dbPrefix + pkValueTypeProperty.Column.Name + dbSufix#>")<#= generated #>;
<#
					}
					else if(pkProperty is Oragon.CodeGen.MetaData.Domain.ManyToOneProperty)
					{
						Oragon.CodeGen.MetaData.Domain.ManyToOneProperty pkManyToOneProperty = (Oragon.CodeGen.MetaData.Domain.ManyToOneProperty)pkProperty;
#>
			Id(it => it.<#= pkProperty.Name #>);
<#
					}
					
				}
				
			}
			else
			{
				List<Oragon.CodeGen.MetaData.Domain.Property> pkProperties = new List<Oragon.CodeGen.MetaData.Domain.Property>();
#>
			CompositeId()<#
				foreach(IColumn currentPKColumn in pkColumns)
				{
					Oragon.CodeGen.MetaData.Domain.Property property = GetPropertyByColumn(propertiesToMap, currentPKColumn, false);
					if(property != null)
					{
						if(property is ValueTypeProperty)
						{
							ValueTypeProperty propValueTypeProperty = (ValueTypeProperty)property;
#> 					
					.KeyProperty(it => it.<#= propValueTypeProperty.Name #>, "<#= string.Concat(dbPrefix, propValueTypeProperty.Column.Name, dbSufix) #>")<#
						}
						else
						{
							ManyToOneProperty propManyToOneProperty = (ManyToOneProperty)property;
							string[] columnNames = propManyToOneProperty.ForeignKey.ForeignColumns.Select(it => string.Concat(@"""", dbPrefix, it.Name, dbSufix,  @"""")).ToArray();
							string referenceColumns = string.Join(", ", columnNames);
#>				
					.KeyReference(it => it.<#= property.Name #>, <#=referenceColumns#>)<#
						}
						propertiesToMap.Remove(property);
					}
				}
#>;
<#

			}

			//################################################################################################################################################################################################################################################### 
			//###################################################################################################################################################################################################################################################


			// Carregando Propriedades Que não fazem parte da PK;


			//################################################################################################################################################################################################################################################### 
			//###################################################################################################################################################################################################################################################


		foreach (Oragon.CodeGen.MetaData.Domain.Property currentProperty in propertiesToMap)
		{
			if (currentProperty is OneToManyProperty)
			{
				OneToManyProperty propOneToManyProperty = (OneToManyProperty)currentProperty;
				string[] columnNames = propOneToManyProperty.ForeignKey.ForeignColumns.Select(it => string.Concat(@"""", dbPrefix, it.Name, dbSufix,  @"""")).ToArray();
				string referenceColumns = string.Join(", ", columnNames);
				
				
#>
			HasMany(x => x.<#= propOneToManyProperty.Name #>)
				.KeyColumns.Add(<#= referenceColumns #>)
				.ForeignKeyConstraintName("<#= string.Concat(dbPrefix, propOneToManyProperty.ForeignKey.Name, dbSufix)  #>")
				.Inverse()
				.Cascade.Delete()<#if(propOneToManyProperty.DeleteCascade){ #>
				.ForeignKeyCascadeOnDelete()<# } #>				
				.LazyLoad()
				.Fetch.Select()
				.AsBag();
<#
			}
			if (currentProperty is ManyToOneProperty)
			{
				ManyToOneProperty propManyToOneProperty = (ManyToOneProperty)currentProperty;
				
				string[] columnNames = propManyToOneProperty.ForeignKey.ForeignColumns.Select(it => string.Concat(@"""", dbPrefix, it.Name, dbSufix, @"""")).ToArray();
				string referenceColumns = string.Join(", ", columnNames);

#>
			References(x => x.<#= propManyToOneProperty.Name #>)
				.ForeignKey("<#= string.Concat(dbPrefix, propManyToOneProperty.ForeignKey.Name , dbSufix) #>")
				.Columns(<#= referenceColumns #>)
				.Fetch.Join()				
				.Cascade.None();
<#
			}
			if (currentProperty is ManyToManyProperty)
			{
				ManyToManyProperty propManyToManyProperty = (ManyToManyProperty)currentProperty;
				string[] parentColumnNames = propManyToManyProperty.RightForeignKey.ForeignColumns.Select(it => string.Concat(@"""", dbPrefix, it.Name, dbSufix, @"""")).ToArray();
				string parentKeyColumnsText = string.Join(", ", parentColumnNames);

				string[] childColumnNames = propManyToManyProperty.LeftForeignKey.ForeignColumns.Select(it => string.Concat(@"""", dbPrefix, it.Name, dbSufix, @"""")).ToArray();
				string childKeyColumnsText = string.Join(", ", childColumnNames);


#>
			HasManyToMany(x => x.<#= propManyToManyProperty.Name #>)
				.ParentKeyColumns.Add(<#= childKeyColumnsText #>)
				.Table("<#= string.Concat(dbPrefix, propManyToManyProperty.Table.Name, dbSufix)   #>")
				.ChildKeyColumns.Add(<#= parentKeyColumnsText #>)
				.LazyLoad()
				.Fetch.Select()
				.AsBag();
<#

			}
			if (currentProperty is ValueTypeProperty)
			{
				ValueTypeProperty propValueTypeProperty = (ValueTypeProperty)currentProperty;
				string stringInfo = string.Empty;

				if(propValueTypeProperty.Column.IsNullable)
					stringInfo += ".Nullable()";
				else
					stringInfo += ".Not.Nullable()";
					
				if(propValueTypeProperty.Column.DataTypeNameComplete == "TIME")
					stringInfo += @".CustomType(""TimeAsTimeSpan"")";
				
				
				if(propValueTypeProperty.Column.IsComputed)
						stringInfo += ".ReadOnly()";

				stringInfo += string.Format(".CustomSqlType(\"{0}\")", propValueTypeProperty.Column.DataTypeNameComplete);
				
				string[] textItems = new string[]{ "nvarchar", "varchar", "nvarchar", "ntext", "char", "nchar" };
				if(textItems.Contains(propValueTypeProperty.Column.DataTypeName))
					stringInfo += string.Format(".Length({0})", propValueTypeProperty.Column.CharacterMaxLength);
				
				
#>
			Map(it => it.<#=propValueTypeProperty.Name#>, "<#=  string.Concat(dbPrefix, propValueTypeProperty.Column.Name, dbSufix) #>")<#=stringInfo#>;
<#				
			}

		}
		
#>			this.CompleteMappings();
		}
		
	}
<# 
}		
#>	
}
 




<#+  
	 //################################################################################################################################################################################################################################################### 
	 //###################################################################################################################################################################################################################################################





	   //################################################################################################################################################################################################################################################### 
	  //###################################################################################################################################################################################################################################################

	public string FirstLower(string value)
	{
		string str = value.Substring(0, 1).ToLower() + value.Substring(1, value.Length - 1);
		return str;
	}

	public Entity GetEntityByTable(DomainModel domain, ITable table)
	{
		return domain.Entities.Where(it => it.Table.Name == table.Name).First();
	}

	public Oragon.CodeGen.MetaData.Domain.Property GetPropertyByColumn(List<Oragon.CodeGen.MetaData.Domain.Property> properties, IColumn column, bool remove)
	{
		Oragon.CodeGen.MetaData.Domain.Property returnValue = GetPropertyByColumn(properties, column);
		if(remove)
		{
			properties.Remove(returnValue);
		}
		return returnValue;
	}

	public Oragon.CodeGen.MetaData.Domain.Property GetPropertyByColumn(List<Oragon.CodeGen.MetaData.Domain.Property> properties, IColumn column)
	{
		Oragon.CodeGen.MetaData.Domain.Property returnValue = null;
		
		foreach (Oragon.CodeGen.MetaData.Domain.Property currentProperty in properties)
		{
			if (currentProperty is OneToManyProperty)
			{
				OneToManyProperty propOneToManyProperty = (OneToManyProperty)currentProperty;
				if (propOneToManyProperty.ForeignKey.PrimaryColumns.Contains(column))
				{
					returnValue = currentProperty;
					break;
				}
			}
			else if (currentProperty is ManyToOneProperty)
			{
				ManyToOneProperty propManyToOneProperty = (ManyToOneProperty)currentProperty;
				if(propManyToOneProperty.ForeignKey.ForeignColumns.Select(it => it.Name).Contains(column.Name))
				{
					returnValue = currentProperty;
					break;
				}
			}
			else if (currentProperty is ManyToManyProperty)
			{
				ManyToManyProperty propManyToManyProperty = (ManyToManyProperty)currentProperty;
				if(propManyToManyProperty.LeftForeignKey.PrimaryColumns.Contains(column))
				{
					returnValue = currentProperty;
					break;
				}
			}
			else if (currentProperty is ValueTypeProperty)
			{
				ValueTypeProperty propValueTypeProperty = (ValueTypeProperty)currentProperty;
				if(propValueTypeProperty.Column == column)
				{
					returnValue = currentProperty;
					break;
				}				
			}

		}



		return returnValue;



	}


	
#>